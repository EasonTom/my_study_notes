# python面试题 
## 1 scrapy的组件？各个组件的功能，联系？
![](https://img-blog.csdn.net/20180210210437328)
### 1.1 组件
- 引擎(Scrapy): 用来处理整个系统的数据流处理, 触发事务(框架核心)
- 调度器(Scheduler): 用来接受引擎发过来的请求, 压入队列中, 并在引擎再次请求的时候返回. 可以想像成一个URL（抓取网页的网址或者说是链接）的优先队列, 由它来决定下一个要抓取的网址是什么, 同时去除重复的网址
- 下载器(Downloader): 用于下载网页内容, 并将网页内容返回给爬虫(Scrapy下载器是建立在twisted这个高效的异步模型上的)
- 爬虫(Spiders): 用于从特定的网页中提取自己需要的信息, 即所谓的实体(Item)。也可以从中提取出链接,返回给调度器让Scrapy继续抓取下一个页面
- 项目管道(Pipeline): 负责处理爬虫从网页中抽取的实体，主要的功能是持久化实体、验证实体的有效性、清除不需要的信息。当页面被爬虫解析后，将被发送到项目管道，并经过几个特定的次序处理数据。
- 下载器中间件(Downloader Middlewares): 位于Scrapy引擎和下载器之间的框架，主要是处理Scrapy引擎与下载器之间的请求及响应。
- 爬虫中间件(Spider Middlewares): 介于Scrapy引擎和爬虫之间的框架，主要工作是处理蜘蛛的响应输入和请求输出。
- 调度中间件(Scheduler Middewares): 介于Scrapy引擎和调度之间的中间件，处理从Scrapy引擎发送到调度的请求和响应。
### 1.2 运行流程
- 首先，引擎从调度器中取出一个链接(URL)用于接下来的抓取
- 引擎把URL封装成一个请求(Request)传给下载器，下载器把资源下载下来，并封装成应答包(Response)传给爬虫
- 然后，爬虫解析Response
- 若是解析出实体（Item）,则交给实体管道进行进一步的处理。
- 若是解析出的是链接（URL）,则把URL交给Scheduler等待抓取

## 2 Scrapy的去重原理
对于每一个url的请求，调度器都会根据请求得相关信息加密得到一个指纹信息，并且将指纹信息和set()集合中的指纹信息进行比对，如果set()集合中已经存在这个数据，就不在将这个Request放入队列中。如果set()集合中没有存在这个加密后的数据，就将这个Request对象放入队列中，等待被调度。
## 3 Scrapy中自定义命令同时运行多个爬虫文件
- 在spiders文件同级建立一个commands文件夹，建立一个py文件。
    
    from scrapy.commands import ScrapyCommand
 
 
    class Command(ScrapyCommand):
    requires_project = True
 
        def syntax(self):
            return '[options]'
 
        def short_desc(self):
            return 'Runs all of the spiders'
 
        def run(self, args, opts):
            spider_list = self.crawler_process.spiders.list()
            for name in spider_list:
            self.crawler_process.crawl(name, **opts.__dict__)
            self.crawler_process.start()

- 在settings文件里把刚建立的crawlall文件的路径设置好

    COMMANDS_MODULE = "ProxyPool.commands"

- 最后在cmd下`scrapy crawlall`运行
## 4 python的内存管理机制
### 4.1 变量和对象

1. 变量，通过变量指针引用对象

　　变量指针指向具体对象的内存空间，取对象的值。

2. 对象，类型已知，每个对象都包含一个头部信息（头部信息：类型标识符和引用计数器）
**变量名没有类型，类型属于对象（因为变量引用对象，所以类型随对象），变量引用什么类型的对象，变量就是什么类型的。**
### 4.2 引用计数
### 4.3 垃圾回收
当Python的某个对象的引用计数降为0时，说明没有任何引用指向该对象，该对象就成为要被回收的垃圾。比如某个新建对象，被分配给某个引用，对象的引用计数变为1。如果引用被删除，对象的引用计数为0，那么该对象就可以被垃圾回收。
### 4.4 分代回收
Python将所有的对象分为0，1，2三代；

　　所有的新建对象都是0代对象；

　　当某一代对象经历过垃圾回收，依然存活，就被归入下一代对象。
### 4.5 内存池

## 5 HTML与XML的区别
xml和html都是用于操作数据或数据结构，在结构上大致是相同的，但它们在本质上却存在着明显的区别。

一、名称

HTML：超文本标记语言

XML：可扩展标记语言

二、不同点

1、语法上

      HTML：语法要求不是很严格，例如：不严格区分大小写，可自动过滤空格，可以不适用引号等。

      XML：与之相反。

2、标记不同

      html使用固有的标记；而xml没有固有的标记。

      Html标签是预定义的；XML标签是免费的、自定义的、可扩展的。

3、作用不同

html是用来显示数据的；xml是用来描述数据、存放数据的，所以可以作为持久化的介质。Html将数据和显示结合在一起，在页面中把这数据显示出来；xml则将数据和显示分开。 XML被设计用来描述数据，其焦点是数据的内容。HTML被设计用来显示数据，其焦点是数据的外观。

## 6 Scrapy去重原理
对于每一个url的请求，调度器都会根据请求得相关信息加密得到一个指纹信息，并且将指纹信息和set()集合中的指纹信息进 行 比对
## 7 http和https的区别
HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

　　HTTPS和HTTP的区别主要如下：

　　1、https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。

　　2、http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。

　　3、http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。

　　4、http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。
　　
## 8 三次握手四次挥手
TCP的连接建立是一个三次握手过程，目的是为了通信双方确认开始序号，以便后续
通信的有序进行。主要步骤如下：
1. 连接开始时，连接建立方(Client)发送SYN包，并包含了自己的初始序号a；
2. 连接接受方(Server)收到SYN包以后会回复一个SYN包，其中包含了对上一个a包
的回应信息ACK，回应的序号为下一个希望收到包的序号，即a＋1，然后还包含
了自己的初始序号b；
3. 连接建立方(Client)收到回应的SYN包以后，回复一个ACK包做响应，其中包含了
下一个希望收到包的序号即b＋1。

TCP终止连接的四次握手过程如下：
1. 首先进行关闭的一方（即发送第一个FIN）将执行主动关闭，而另一方（收到这
个FIN）执行被动关闭。
2. 当服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一
样，一个FIN将占用一个序号。
3. 同时TCP服务器还向应用程序（即丢弃服务器）传送一个文件结束符。接着这个
服务器程序就关闭它的连接，导致它的TCP端发送一个FIN。
4. 客户必须发回一个确认，并将确认序号设置为收到序号加1。
## 9 常见设计模式与单例模式的实现
模式是一条由三个部分组成的通用规则：它表示了一个特定环境、一类问题和一个解决方案之间的关系。每一个模式描述了一个不断重复发生的问题，以及该问题解决方案的核心设计。
### 9.1 软件设计模式的分类
1. 创建型
创建对象时，不再由我们直接实例化对象；而是根据特定场景，由程序来确定创建对象的方式，从而保证更大的性能、更好的架构优势。创建型模式主要有简单工厂模式（并不是23种设计模式之一）、工厂方法、抽象工厂模式、单例模式、生成器模式和原型模式。
2. 结构型
用于帮助将多个对象组织成更大的结构。结构型模式主要有适配器模式adapter、桥接模式bridge、组合器模式component、装饰器模式decorator、门面模式、亨元模式flyweight和代理模式proxy。
3. 行为型
用于帮助系统间各对象的通信，以及如何控制复杂系统中流程。行为型模式主要有命令模式command、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式state、策略模式、模板模式和访问者模式。
### 9.2 python实现单例模式
单例模式即一个类有且仅有一个实例。

python中，一个类创建对象实例是通过调用父类object的`__new__(cls)`方法来创建对象的，可以通过重写` __new__(cls)`方法去实现类只创建一个实例。

    class Earth(object):
        __instance=None #定义一个类属性做判断
 
        def __new__(cls):
     
            if cls.__instance==None:
                #如果__instance为空证明是第一次创建实例
                #通过父类的__new__(cls)创建实例
                cls.__instance==object.__new__(cls)
            return cls.__instance
            

然后创建两个实例，查看它们的内存发现是一样的，表示它们是同一个对象。

    a = Earth()
    print(id(a))
    b = Earth()
    print(id(b))
## 10 常见IO模型及其优缺点

1.同步阻塞IO（Blocking IO）：即传统的IO模型。

2.同步非阻塞IO（Non-blocking IO）：默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。注意这里所说的NIO并非Java的NIO（New IO）库。

3.IO多路复用（IO Multiplexing）：即经典的Reactor设计模式，有时也称为异步阻塞IO，Java中的Selector和Linux中的epoll都是这种模型。

4.异步IO（Asynchronous IO）：即经典的Proactor设计模式，也称为异步非阻塞IO。

总结来说就是同步阻塞、同步非阻塞、异步阻塞、异步非阻塞四种。

二、同步与异步

1.同步:同步是指用户线程发起IO请求后需要等待或者轮询内核IO操作完成后才能继续执行；

2.异步：异步是指用户线程发起IO请求后仍继续执行，当内核IO操作完成后会通知用户线程，或者调用用户线程注册的回调函数。

三、阻塞与非阻塞

1.阻塞：阻塞是指IO操作需要彻底完成后才返回到用户空间；

2.非阻塞：非阻塞是指IO操作被调用后立即返回给用户一个状态值，无需等到IO操作彻底完成。

四、同步阻塞IO模型

整个IO请求的过程中，用户线程是被阻塞的，这导致用户在发起IO请求时，不能做任何事情，对CPU的资源利用率不够。

五、同步非阻塞IO



整个IO请求的过程中，虽然用户线程每次发起IO请求后可以立即返回，但是为了等到数据，仍需要不断地轮询、重复请求，消耗了大量的CPU的资源。一般很少直接使用这种模型，而是在其他IO模型中使用非阻塞IO这一特性。

六、IO多路复用模型

IO多路复用模型是建立在内核提供的多路分离函数select基础之上的，使用select函数可以避免同步非阻塞IO模型中轮询等待的问题。IO多路复用是最常使用的IO模型，但是其异步程度还不够“彻底”，因为它使用了会阻塞线程的select系统调用。因此IO多路复用只能称为异步阻塞IO，而非真正的异步IO。


七、异步IO模型

“真正”的异步IO需要操作系统更强的支持。在IO多路复用模型中，事件循环将文件句柄的状态事件通知给用户线程，由用户线程自行读取数据、处理数据。而在异步IO模型中，当用户线程收到通知时，数据已经被内核读取完毕，并放在了用户线程指定的缓冲区内，内核在IO完成后通知用户线程直接使用即可。异步IO模型使用了Proactor设计模式实现了这一机制。

相比于IO多路复用模型，异步IO并不十分常用，不少高性能并发服务程序使用IO多路复用模型+多线程任务处理的架构基本可以满足需求。况且目前操作系统对异步IO的支持并非特别完善，更多的是采用IO多路复用模型模拟异步IO的方式（IO事件触发时不直接通知用户线程，而是将数据读写完毕后放到用户指定的缓冲区中）。
## 11 python的GIL锁
熟悉python的都知道，在C语言写的python解释器中存在全局解释器锁，由于全局解释器锁的存在，在同一时间内，python解释器只能运行一个线程的代码，这大大影响了python多线程的性能。而这个解释器锁由于历史原因，现在几乎无法消除。python GIL 之所以会影响多线程等性能，是因为在多线程的情况下，只有当线程获得了一个全局锁的时候，那么该线程的代码才能运行，而全局锁只有一个，所以使用python多线程，在同一时刻也只有一个线程在运行，因此在即使在多核的情况下也只能发挥出单核的性能。既然python在同一时刻下只能运行一个线程的代码，那线程之间是如何调度的呢？ 对于有io操作的线程，当一个线程在做io操作的时候，因为io操作不需要cpu，所以，这个时候，python会释放python全局锁，这样其他需要运行的线程就会使用该锁。 对于cpu密集型的线程，比如一个线程可能一直需要使用cpu做计算，那么python中会有一个执行指令的计数器，当一个线程执行了一定数量的指令时，该线程就会停止执行并让出当前的锁，这样其他的线程就可以执行代码了。 由上面可知，至少有两种情况python会做线程切换，一是一但有IO操作时，会有线程切换，二是当一个线程连续执行了一定数量的指令时，会出现线程切换。当然此处的线程切换不一定就一定会切换到其他线程执行，因为如果当前线程 优先级比较高的话，可能在让出锁以后，又继续获得锁，并优先执行。在做科学计算的时候是用的单线程，因为这种计算是需要CPU一直做计算的，如果用多线程反而会降低计算速度。
